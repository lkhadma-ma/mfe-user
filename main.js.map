{"version":3,"sources":["node_modules/@softarc/native-federation-runtime/fesm2022/softarc-native-federation-runtime.mjs","projects/user/src/main.ts"],"sourcesContent":["const defaultShareOptions = {\n    singleton: false,\n    requiredVersionPrefix: '',\n};\nfunction getShared(options = defaultShareOptions) {\n    const nfc = window;\n    const externals = nfc.__NATIVE_FEDERATION__.externals;\n    const shared = {};\n    const allKeys = [...externals.keys()];\n    const keys = allKeys\n        .filter((k) => !k.startsWith('/@id/') &&\n        !k.startsWith('@angular-architects/module-federation') &&\n        !k.endsWith('@'))\n        .sort();\n    for (const key of keys) {\n        const idx = key.lastIndexOf('@');\n        const pkgName = key.substring(0, idx);\n        const version = key.substring(idx + 1);\n        const path = externals.get(key) ?? '';\n        const shareObj = {\n            version,\n            get: async () => {\n                const lib = await window.importShim(path);\n                return () => lib;\n            },\n            shareConfig: {\n                singleton: options.singleton,\n                requiredVersion: options.requiredVersionPrefix + version,\n            },\n        };\n        if (!shared[pkgName]) {\n            shared[pkgName] = [];\n        }\n        shared[pkgName].push(shareObj);\n    }\n    return shared;\n}\n\nconst nfNamespace = '__NATIVE_FEDERATION__';\nconst global = globalThis;\nglobal[nfNamespace] ??= {\n    externals: new Map(),\n    remoteNamesToRemote: new Map(),\n    baseUrlToRemoteNames: new Map(),\n};\nconst globalCache = global[nfNamespace];\n\nconst externals = globalCache.externals;\nfunction getExternalKey(shared) {\n    return `${shared.packageName}@${shared.version}`;\n}\nfunction getExternalUrl(shared) {\n    const packageKey = getExternalKey(shared);\n    return externals.get(packageKey);\n}\nfunction setExternalUrl(shared, url) {\n    const packageKey = getExternalKey(shared);\n    externals.set(packageKey, url);\n}\n\nfunction mergeImportMaps(map1, map2) {\n    return {\n        imports: { ...map1.imports, ...map2.imports },\n        scopes: { ...map1.scopes, ...map2.scopes },\n    };\n}\n\nconst remoteNamesToRemote = globalCache.remoteNamesToRemote;\nconst baseUrlToRemoteNames = globalCache.baseUrlToRemoteNames;\nfunction addRemote(remoteName, remote) {\n    remoteNamesToRemote.set(remoteName, remote);\n    baseUrlToRemoteNames.set(remote.baseUrl, remoteName);\n}\nfunction getRemoteNameByBaseUrl(baseUrl) {\n    return baseUrlToRemoteNames.get(baseUrl);\n}\nfunction isRemoteInitialized(baseUrl) {\n    return baseUrlToRemoteNames.has(baseUrl);\n}\nfunction getRemote(remoteName) {\n    return remoteNamesToRemote.get(remoteName);\n}\nfunction hasRemote(remoteName) {\n    return remoteNamesToRemote.has(remoteName);\n}\n\nfunction appendImportMap(importMap) {\n    document.head.appendChild(Object.assign(document.createElement('script'), {\n        type: 'importmap-shim',\n        innerHTML: JSON.stringify(importMap),\n    }));\n}\n\nfunction getDirectory(url) {\n    const parts = url.split('/');\n    parts.pop();\n    return parts.join('/');\n}\nfunction joinPaths(path1, path2) {\n    while (path1.endsWith('/')) {\n        path1 = path1.substring(0, path1.length - 1);\n    }\n    if (path2.startsWith('./')) {\n        path2 = path2.substring(2, path2.length);\n    }\n    return `${path1}/${path2}`;\n}\n\nconst BUILD_NOTIFICATIONS_ENDPOINT = '/@angular-architects/native-federation:build-notifications';\nvar BuildNotificationType;\n(function (BuildNotificationType) {\n    BuildNotificationType[\"COMPLETED\"] = \"federation-rebuild-complete\";\n    BuildNotificationType[\"ERROR\"] = \"federation-rebuild-error\";\n})(BuildNotificationType || (BuildNotificationType = {}));\n\n/**\n * Watches for federation build completion events and automatically reloads the page.\n *\n * This function establishes a Server-Sent Events (SSE) connection to listen for\n * 'federation-rebuild-complete' notifications. When a build completes successfully,\n * it triggers a page reload to reflect the latest changes.\n * @param endpoint - The SSE endpoint URL to watch for build notifications.\n */\nfunction watchFederationBuildCompletion(endpoint) {\n    const eventSource = new EventSource(endpoint);\n    eventSource.onmessage = function (event) {\n        const data = JSON.parse(event.data);\n        if (data.type === BuildNotificationType.COMPLETED) {\n            console.log('[Federation] Rebuild completed, reloading...');\n            window.location.reload();\n        }\n    };\n    eventSource.onerror = function (event) {\n        console.warn('[Federation] SSE connection error:', event);\n    };\n}\n\n/**\n * Initialize the federation runtime\n * @param remotesOrManifestUrl\n * @param options The cacheTag allows you to invalidate the cache of the remoteEntry.json files, pass a new value with every release (f.ex. the version number)\n */\nasync function initFederation(remotesOrManifestUrl = {}, options) {\n    const cacheOption = options?.cacheTag ? `?t=${options.cacheTag}` : '';\n    const remotes = typeof remotesOrManifestUrl === 'string'\n        ? await loadManifest(remotesOrManifestUrl + cacheOption)\n        : remotesOrManifestUrl;\n    const url = './remoteEntry.json' + cacheOption;\n    const hostInfo = await loadFederationInfo(url);\n    const hostImportMap = await processHostInfo(hostInfo);\n    const remotesImportMap = await processRemoteInfos(remotes, {\n        throwIfRemoteNotFound: false,\n        ...options,\n    });\n    const importMap = mergeImportMaps(hostImportMap, remotesImportMap);\n    appendImportMap(importMap);\n    return importMap;\n}\nasync function loadManifest(remotes) {\n    return (await fetch(remotes).then((r) => r.json()));\n}\nasync function processRemoteInfos(remotes, options = { throwIfRemoteNotFound: false }) {\n    const processRemoteInfoPromises = Object.keys(remotes).map(async (remoteName) => {\n        try {\n            let url = remotes[remoteName];\n            if (options.cacheTag) {\n                const addAppend = remotes[remoteName].includes('?') ? '&' : '?';\n                url += `${addAppend}t=${options.cacheTag}`;\n            }\n            return await processRemoteInfo(url, remoteName);\n        }\n        catch (e) {\n            const error = `Error loading remote entry for ${remoteName} from file ${remotes[remoteName]}`;\n            if (options.throwIfRemoteNotFound) {\n                throw new Error(error);\n            }\n            console.error(error);\n            return null;\n        }\n    });\n    const remoteImportMaps = await Promise.all(processRemoteInfoPromises);\n    const importMap = remoteImportMaps.reduce((acc, remoteImportMap) => remoteImportMap ? mergeImportMaps(acc, remoteImportMap) : acc, { imports: {}, scopes: {} });\n    return importMap;\n}\nasync function processRemoteInfo(federationInfoUrl, remoteName) {\n    const baseUrl = getDirectory(federationInfoUrl);\n    const remoteInfo = await loadFederationInfo(federationInfoUrl);\n    if (!remoteName) {\n        remoteName = remoteInfo.name;\n    }\n    if (remoteInfo.buildNotificationsEndpoint) {\n        watchFederationBuildCompletion(baseUrl + remoteInfo.buildNotificationsEndpoint);\n    }\n    const importMap = createRemoteImportMap(remoteInfo, remoteName, baseUrl);\n    addRemote(remoteName, { ...remoteInfo, baseUrl });\n    return importMap;\n}\nfunction createRemoteImportMap(remoteInfo, remoteName, baseUrl) {\n    const imports = processExposed(remoteInfo, remoteName, baseUrl);\n    const scopes = processRemoteImports(remoteInfo, baseUrl);\n    return { imports, scopes };\n}\nasync function loadFederationInfo(url) {\n    const info = (await fetch(url).then((r) => r.json()));\n    return info;\n}\nfunction processRemoteImports(remoteInfo, baseUrl) {\n    const scopes = {};\n    const scopedImports = {};\n    for (const shared of remoteInfo.shared) {\n        const outFileName = getExternalUrl(shared) ?? joinPaths(baseUrl, shared.outFileName);\n        setExternalUrl(shared, outFileName);\n        scopedImports[shared.packageName] = outFileName;\n    }\n    scopes[baseUrl + '/'] = scopedImports;\n    return scopes;\n}\nfunction processExposed(remoteInfo, remoteName, baseUrl) {\n    const imports = {};\n    for (const exposed of remoteInfo.exposes) {\n        const key = joinPaths(remoteName, exposed.key);\n        const value = joinPaths(baseUrl, exposed.outFileName);\n        imports[key] = value;\n    }\n    return imports;\n}\nasync function processHostInfo(hostInfo, relBundlesPath = './') {\n    const imports = hostInfo.shared.reduce((acc, cur) => ({\n        ...acc,\n        [cur.packageName]: relBundlesPath + cur.outFileName,\n    }), {});\n    for (const shared of hostInfo.shared) {\n        setExternalUrl(shared, relBundlesPath + shared.outFileName);\n    }\n    return { imports, scopes: {} };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nasync function loadRemoteModule(optionsOrRemoteName, exposedModule) {\n    const options = normalizeOptions(optionsOrRemoteName, exposedModule);\n    await ensureRemoteInitialized(options);\n    const remoteName = getRemoteNameByOptions(options);\n    const remote = getRemote(remoteName);\n    const fallback = options.fallback;\n    const remoteError = !remote ? 'unknown remote ' + remoteName : '';\n    if (!remote && !fallback) {\n        throw new Error(remoteError);\n    }\n    else if (!remote) {\n        logClientError(remoteError);\n        return Promise.resolve(fallback);\n    }\n    const exposed = remote.exposes.find((e) => e.key === options.exposedModule);\n    const exposedError = !exposed\n        ? `Unknown exposed module ${options.exposedModule} in remote ${remoteName}`\n        : '';\n    if (!exposed && !fallback) {\n        throw new Error(exposedError);\n    }\n    else if (!exposed) {\n        logClientError(exposedError);\n        return Promise.resolve(fallback);\n    }\n    const url = joinPaths(remote.baseUrl, exposed.outFileName);\n    try {\n        const module = _import(url);\n        return module;\n    }\n    catch (e) {\n        if (fallback) {\n            console.error('error loading remote module', e);\n            return fallback;\n        }\n        throw e;\n    }\n}\nfunction _import(url) {\n    return typeof importShim !== 'undefined'\n        ? importShim(url)\n        : import(/* @vite-ignore */ url);\n}\nfunction getRemoteNameByOptions(options) {\n    let remoteName;\n    if (options.remoteName) {\n        remoteName = options.remoteName;\n    }\n    else if (options.remoteEntry) {\n        const baseUrl = getDirectory(options.remoteEntry);\n        remoteName = getRemoteNameByBaseUrl(baseUrl);\n    }\n    else {\n        throw new Error('unexpcted arguments: Please pass remoteName or remoteEntry');\n    }\n    if (!remoteName) {\n        throw new Error('unknown remoteName ' + remoteName);\n    }\n    return remoteName;\n}\nasync function ensureRemoteInitialized(options) {\n    if (options.remoteEntry &&\n        !isRemoteInitialized(getDirectory(options.remoteEntry))) {\n        const importMap = await processRemoteInfo(options.remoteEntry);\n        appendImportMap(importMap);\n    }\n}\nfunction normalizeOptions(optionsOrRemoteName, exposedModule) {\n    let options;\n    if (typeof optionsOrRemoteName === 'string' && exposedModule) {\n        options = {\n            remoteName: optionsOrRemoteName,\n            exposedModule,\n        };\n    }\n    else if (typeof optionsOrRemoteName === 'object' && !exposedModule) {\n        options = optionsOrRemoteName;\n    }\n    else {\n        throw new Error('unexpected arguments: please pass options or a remoteName/exposedModule-pair');\n    }\n    return options;\n}\nfunction logClientError(error) {\n    if (typeof window !== 'undefined') {\n        console.error(error);\n    }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BUILD_NOTIFICATIONS_ENDPOINT, BuildNotificationType, getShared, initFederation, loadRemoteModule, mergeImportMaps, processHostInfo, processRemoteInfo, processRemoteInfos };\n\n","import { initFederation } from '@angular-architects/native-federation';\n\ninitFederation()\n  .catch(err => console.error(err))\n  .then(_ => import('./bootstrap'))\n  .catch(err => console.error(err));\n"],"mappings":"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","names":["BuildNotificationType"],"x_google_ignoreList":[0]}